# Copyright (c) 2011-2013 Spotify AB
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

from crtauth.exceptions import InvalidInputException

field_fstring = (
    lambda P, p, v, (size,): p.pack_fstring(size, v),
    lambda P, u, (size,): u.unpack_fstring(size)
    )

field_string = (
    lambda P, p, v, _: p.pack_string(v),
    lambda P, u, _: u.unpack_string()
    )

field_uint = (
    lambda P, p, v, _: p.pack_uint(v),
    lambda P, u, _: u.unpack_uint()
    )

field_type = (
    lambda P, p, v, _: p.pack_string(v.serialize(P)),
    lambda P, u, (cls,): cls.deserialize(P, u.unpack_string())
    )


class SerializablePacket(object):
    __magic__ = None
    __fields__ = None

    def __init__(self, **kw):
        if len(kw) != len(self.__fields__):
            raise RuntimeError("Field length mismatch")

        for key, _ in self.__fields__:
            val = kw.get(key, None)
            if val is None:
                raise RuntimeError("Missing required argument '" + key + "'")
            setattr(self, key, val)

    def serialize(self, packing):
        if self.__magic__ is None or self.__fields__ is None:
            raise RuntimeError("Serialization can only be performed on classes "
                               "implementing __fields__ and __magic__")

        p = packing.Packer()

        p.pack_fstring(1, self.__magic__)

        for name, ((sx, _), opts) in self.__fields__:
            sx(packing, p, getattr(self, name), opts)

        return p.get_buffer()

    @classmethod
    def deserialize(cls, packing, buf):
        if cls.__magic__ is None or cls.__fields__ is None:
            raise RuntimeError("Deserialization can only be performed on classes "
                               "implementing __fields__ and __magic__")

        u = packing.Unpacker(buf)

        if u.unpack_fstring(1) != cls.__magic__:
            raise InvalidInputException("Wrong magic byte for " + cls.__name__ + " "
                                                                                 "(should be '" + hex(ord(cls.__magic__)) + "')")

        kw = dict()

        for name, ((_, dx), opts) in cls.__fields__:
            kw[name] = dx(packing, u, opts)

        return cls(**kw)

class VerifiablePayload(SerializablePacket):
    """
    A digest and payload combination.

    digest - The payload digest.
    payload - The payload.
    """

    __magic__ = 'v'

    __fields__ = [
        ("digest", (field_fstring, (20,))),
        ("payload", (field_string, None))
    ]

    def verify(self, digest_f):
        return self.digest == digest_f(self.payload)

class Challenge(SerializablePacket):
    """
    Represents a challenge, with binary serialization support
    """

    __magic__ = 'c'

    __fields__ = [
        ("unique_data", (field_fstring, (20,))),
        ("valid_from", (field_uint, None)),
        ("valid_to", (field_uint, None)),
        ("fingerprint", (field_string, None)),
        ("server_name", (field_string, None)),
        ("username", (field_string, None))
    ]

class Response(SerializablePacket):
    """
    Represents a response to a challenge.

    signature - A signature generated by the client.
    hmac_challenge - A verifiable packed challenge (see VerifiablePayload).
    """
    __magic__ = 'r'

    __fields__ = [
        ("signature", (field_string, None)),
        ("hmac_challenge", (field_type, (VerifiablePayload,)))
    ]

class Token(SerializablePacket):
    """
    A token which verifies that can be used to authorize a specific user.
    """
    __magic__ = 't'

    __fields__ = (
        ("valid_from", (field_uint, None)),
        ("valid_to", (field_uint, None)),
        ("username", (field_string, None))
        )

